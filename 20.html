<!DOCTYPE html>
<html><head></head><body>
<div id="cover" style="position:fixed;width:100vw;height:100vh;background-color:#222;z-index:2;top:0;left:0;"></div>
<div id="top"></div>
<div id="page-wrapper"><div id="content-wrapper">
<div id="main-content">

# **Regex demo 1**

**What does a **`?`** do in regex?**

There are two different uses. The simpler is that it makes a thing optional. `/bag/` matches "bag", while `/bag?/` matches "bag" and "ba", because it's saying `ba` and then an optional `g` that can either be there or not. This is identical to say `/bag{0,1}/`, as it matches `g` either 1 or 0 times. A way you might use this is if you wanted to match both variant spellings of cancelled, which only has one L in American English, by saying `/cancell?ed/`.

The second use is that it modifies the `*` and `+` quantifiers. If you say `h+`, that means any amount of `h`, whether `h` or `hhhhh`. If you say `h*`, that's the same idea, but it would also include zero h's.

The problem is sometimes it's ambiguous when a quantifier is supposed to stop.

Consider this: (This is) a (sentence) with (some) brackets.

If I searched for `\(.+\)`, it could return `(This is)`, but why doesn't the `.` just carry on until the next `)`? It could return `(This is) a (sentence) with (some)`.

The default behaviour is for selectors to grab as much as they can. In that scenario, the `+` would go until the very last instance of `)` it can find. If you put a `?` after the `+`, it instead stops after the first one. We call these different modes lazy and greedy. By default, selectors are greedy, but `?` changes them into lazy.

```
let sample= "(This is the difference) between a lazy selector) and a greedy one)";
 
console.log(/\(.+\)/.exec(sample)[0]);
console.log(/\(.+?\)/.exec(sample)[0]);

</div>
</div>
</div>
<script src="assets/interpreter.js"></script>
<script src="assets/layout.js"></script>
</body></html>
